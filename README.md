# [Design and Analysis of Algorithms](https://github.com/HarishShan23/daa_codes)

#### Navigate to Week 

<a href="#w1"> `Week 1`</a>	
<a href="#w2"> `Week 2`</a>
<a href="#w3"> `Week 3`</a>	
<a href="#w4"> `Week 4`</a>
<a href="#w5"> `Week 5`</a>	


## [WEEK 1](https://github.com/HarishShan23/daa_codes/tree/main/Week%201)<span id="w1"></span>

[Q1](https://github.com/HarishShan23/daa_codes/blob/main/Week%201/find_max.cpp) Given an integer array, present three different logic to find MAXIMUM in an array. For each logic, count the number of comparisons incurred to return MAX. 

[Q2](https://github.com/HarishShan23/daa_codes/blob/main/Week%201/neither_min_nor_max.cpp) Given an integer array, present a logic to output an element which is neither maximum nor minimum. 

[Q3](https://github.com/HarishShan23/daa_codes/blob/main/Week%201/prime_factors.cpp) Given a number, write an algorithm to list all its prime factors.

[Q4](https://github.com/HarishShan23/daa_codes/blob/main/Week%201/gcd_lcm.cpp) Given two integers (m,n), present three different approaches to find GCD(m,n) and LCM(m,n). Make an attempt with the logic of Q3 for one of the approaches.

## [WEEK 2](https://github.com/HarishShan23/daa_codes/tree/main/Week%202)<span id="w2"></span>

[Q1](https://github.com/HarishShan23/daa_codes/blob/main/Week%202/find_pairs.cpp) Find pairs of elements in the array whose sum is equal to p.

Input: Integer Array A and an integer p.

[Q2](https://github.com/HarishShan23/daa_codes/blob/main/Week%202/find_num.cpp) Identify the position of the first '-1'

Input: Accept a large sized integer array from the user with the following constraints  
    
    (i) user should not enter the size of the array  

    (ii) user should not enter -1 as it is used delimiter. User enters until some time after which the user must enter -1 only and no other integer, the user can enter -1 any number of times.

[Q3](https://github.com/HarishShan23/daa_codes/blob/main/Week%202/print_pattern.cpp) Print the following five patterns. 

```text

Input : 5

Output:  

1 2 3 4 5
1 2 3 4
1 2 3
1 2
1

1 2 3 4 5
  2 3 4 5
    3 4 5
      4 5
        5

1
1 2
1 2 3
1 2 3 4
1 2 3 4 5

        5
      4 5
    3 4 5
  2 3 4 5
1 2 3 4 5


1 2 3 4 5 6 7 8
  2 3 4 5 6 7
    3 4 5 6
      4 5
      4 5
    3 4 5 6
  2 3 4 5 6 7
1 2 3 4 5 6 7 8
```

## [WEEK 3](https://github.com/HarishShan23/daa_codes/tree/main/Week%203)<span id="w3"></span>

[Q1](https://github.com/HarishShan23/daa_codes/blob/main/Week%203/stable_sort.cpp) Given a ternary array (filled with 0,1,2) of size n. Arrange them in non-decreasing order preserving stability.

[Q2](https://github.com/HarishShan23/daa_codes/blob/main/Week%203/find_duplicates.cpp) Given an integer array, find duplicates in the array. Present two different logic.

[Q4](https://github.com/HarishShan23/daa_codes/blob/main/Week%203/find_subsets_sum_k.cpp) Given an integer array, find if there exists a subset whose sum is k.

[Q4](https://github.com/HarishShan23/daa_codes/blob/main/Week%203/subset_sum.cpp) Given an integer array, find all the subsets whose sum is k. 

## [WEEK 4](https://github.com/HarishShan23/daa_codes/tree/main/Week%204)<span id="w4"></span>

[Q1](https://github.com/HarishShan23/daa_codes/blob/main/Week%204/find_max.cpp) Find maximum element in an array using 1-way, 2-way, 3-way and k-way divide and conquer approach. 

[Q2](https://github.com/HarishShan23/daa_codes/blob/main/Week%204/count_negatives.cpp) Given an integer array, count the number of negative numbers in it using 2-way and 3-way divide and conquer approach.

[Q3](https://github.com/HarishShan23/daa_codes/blob/main/Week%204/binarySearch_ternarySearch.cpp) Implement an Iterative and a Recursive algorithm for Binary Search and Ternary Search.

## [WEEK 5](https://github.com/HarishShan23/daa_codes/tree/main/Week%205)<span id="w5"></span>

[Q1](https://github.com/HarishShan23/daa_codes/blob/main/Week%205/hybrid_merge_sort.cpp) Consider a large integer array of size at least 1000. Populate the array using rand() function. Use 2-way merge sort as part of divide phase and stop the recursion when the input size is less than or equal to 20. For all subproblems of size at most 20, sort the subproblem using Insertion sort, Selection sort, and Bubble sort.

[Q2](https://github.com/HarishShan23/daa_codes/blob/main/Week%205/hybrid_merge_sort_3way.cpp) Consider a large integer array of size at least 1000. Populate the array using rand() function. Use 3-way merge sort as part of divide phase and stop the recursion when the input size is less than or equal to 20. For all subproblems of size at most 20, sort the subproblem using Insertion sort, Selection sort, and Bubble sort.

[Q3](https://github.com/HarishShan23/daa_codes/blob/main/Week%205/dual_pivot_quicksort.cpp) Implement Dual Pivot Quicksort. 

[Q4](https://github.com/HarishShan23/daa_codes/blob/main/Week%205/binary_insertion_sort.cpp) Implement Binary Insertion Sort. 

[Q5](https://github.com/HarishShan23/daa_codes/blob/main/Week%205/merge_array.cpp) Implement 3 different logic to Merge two sorted arrays.

[Q6](https://github.com/HarishShan23/daa_codes/blob/main/Week%205/maxheap_findmin.cpp) Given a max-heap, find the minimum and second minimum elements.